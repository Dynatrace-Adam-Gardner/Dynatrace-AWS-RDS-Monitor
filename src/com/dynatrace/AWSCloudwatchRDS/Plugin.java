
 /**
  * This template file was generated by Dynatrace client.
  * The Dynatrace community portal can be found here: http://community.dynatrace.com/
  * For information how to publish a plugin please visit https://community.dynatrace.com/community/display/DL/How+to+add+a+new+plugin/
  **/ 

package com.dynatrace.AWSCloudwatchRDS;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.logging.Logger;

import com.amazonaws.auth.AWSStaticCredentialsProvider;
import com.amazonaws.auth.BasicAWSCredentials;
import com.amazonaws.client.builder.AwsClientBuilder.EndpointConfiguration;
import com.amazonaws.services.cloudwatch.AmazonCloudWatch;
import com.amazonaws.services.cloudwatch.AmazonCloudWatchClientBuilder;
import com.amazonaws.services.cloudwatch.model.Datapoint;
import com.amazonaws.services.cloudwatch.model.Dimension;
import com.amazonaws.services.cloudwatch.model.GetMetricStatisticsRequest;
import com.amazonaws.services.cloudwatch.model.GetMetricStatisticsResult;
import com.dynatrace.AWSCloudwatchRDS.Constants.IConstants;
import com.dynatrace.diagnostics.pdk.Monitor;
import com.dynatrace.diagnostics.pdk.MonitorEnvironment;
import com.dynatrace.diagnostics.pdk.MonitorMeasure;
import com.dynatrace.diagnostics.pdk.Status;
import com.sun.security.ntlm.Client;

public class Plugin implements Monitor
{
	private static final Logger log = Logger.getLogger(Plugin.class.getName());

	/* Hold the list of possible AWS metrics.
	 * See: http://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/rds-metricscollected.html
	 */
	private List<String> m_oMetrics = new ArrayList<String>();
	
	/*
	 * We will push all aggregations to AppMon
	 * However, remember that not all metrics will be useful.
	 * See: http://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/rds-metricscollected.html
	 */
	private List<String> m_oAggregationList = new ArrayList<String>();
	
	@Override
	public Status setup(MonitorEnvironment env) throws Exception
	{	
        m_oMetrics.add("BinLogDiskUsage");
        m_oMetrics.add("CPUUtilization");
        m_oMetrics.add("CPUCreditUsage");
        m_oMetrics.add("CPUCreditBalance");
        m_oMetrics.add("DatabaseConnections");
        m_oMetrics.add("DiskQueueDepth");
        m_oMetrics.add("FreeableMemory");
        m_oMetrics.add("FreeableStorage");
        m_oMetrics.add("ReplicaLag");
        m_oMetrics.add("SwapUsage");
        m_oMetrics.add("ReadIOPS");
        m_oMetrics.add("WriteIOPS");
        m_oMetrics.add("ReadLatency");
        m_oMetrics.add("WriteLatency");
        m_oMetrics.add("ReadThroughput");
        m_oMetrics.add("WriteThroughput");
        m_oMetrics.add("NetworkReceiveThroughput");
        m_oMetrics.add("NetworkTransmitThroughput");
        
        m_oAggregationList.add(IConstants.AGGREGATION_MINIMUM);
        m_oAggregationList.add(IConstants.AGGREGATION_AVERAGE);
        m_oAggregationList.add(IConstants.AGGREGATION_MAXIMUM);
        m_oAggregationList.add(IConstants.AGGREGATION_SUM);
		m_oAggregationList.add(IConstants.AGGREGATION_SAMPLE_COUNT);
        
		return new Status(Status.StatusCode.Success);
	}

	@Override
	public Status execute(MonitorEnvironment env) throws Exception
	{	
		String strAccessKey = env.getConfigString(IConstants.ACCESS_KEY);
		String strSecretAccessKey = env.getConfigPassword(IConstants.SECRET_KEY);
		String strAWSRegion = env.getConfigString(IConstants.AWS_REGION);
		String strStatsType = env.getConfigString(IConstants.STATS_TYPE); // Signifies Use Case #
		
		/* This will be either:
		 * Empty or null - Use case #1
		 * "my-db-instance" - Use case #2
		 * "mysql" - Use case #3
		 * "db.t2.micro" - Use case #4
		 */
		String strDimensionInput = env.getConfigString(IConstants.DB_DIMENSION_INPUT);
		
		log.fine("Initial Stats Type: " + strStatsType);
		if (strDimensionInput == null | strDimensionInput.isEmpty())
		{
			// Make sure we default back to stats type 1 if no param is used.
			strStatsType = IConstants.ALL_RDS_STATS;
			log.info("Dimension Input empty or null. If you intended to get stats for anything *other* than \"Statistics for all RDS Instances\" then you need to specify this parameter. Setting statsType and falling back to Use Case #1");
		}
		else log.fine("strDimensionInput: " + strDimensionInput);
		
		/*
		 * Possible Values
		 * "1 Minute" | "5 Minutes" | "10 Minutes" | "15 Minutes" | "30 Minutes" | "1 Hour"
		 */
		String strDataGranularity = env.getConfigString(IConstants.DATA_GRANULARITY);
		
		if (strAccessKey == null | strAccessKey.isEmpty())
		{
			log.severe("Missing Access Key. Please configure monitor correctly.");
			return new Status(Status.StatusCode.ErrorInternalConfigurationProblem);
		}

		if (strSecretAccessKey == null | strSecretAccessKey.isEmpty()) log.severe("Missing Secret Access Key. Please configure monitor correctly.");

		if (strAWSRegion == null | strAWSRegion.isEmpty())
		{
			log.severe("Missing AWS Region. Defaulting to eu-west-2. Please configure monitor correctly.");
			strAWSRegion = "eu-west-2";
		}
		
		BasicAWSCredentials oCredentials = new BasicAWSCredentials(strAccessKey, strSecretAccessKey);
        AWSStaticCredentialsProvider oProvider = new AWSStaticCredentialsProvider(oCredentials);

        String strEndpoint = "https://monitoring." + strAWSRegion + ".amazonaws.com"; // monitoring.eu-west-2.amazonaws.com
        
        log.fine("[DEBUG] Endpoint: " + strEndpoint);
        
        EndpointConfiguration oEndpointConfig = new EndpointConfiguration(strEndpoint, strAWSRegion);

        AmazonCloudWatch oClient = AmazonCloudWatchClientBuilder.standard().withCredentials(oProvider).withEndpointConfiguration(oEndpointConfig).build();
        
        
        /*
		 * Calculate start and end time.
		 * This relies on the user-inputtable parameter.
		 * This MUST match the schedule for the plugin.
		 * eg. If the monitor runs every 10mins, the user MUST set this to be 10 mins.
		 * For possible values, see IConstants file.
		 */
		Date oEndTime = new Date();
		int iDataGranularity = calculateDataGranularity(strDataGranularity);
		Date oStartTime = new Date(oEndTime.getTime() - iDataGranularity); // Go back "dataGranularity" and pull data starting from then.
		
        List<GetMetricStatisticsResult> oResultList = new ArrayList<GetMetricStatisticsResult>();

        // Get Metric Results from AWS. This is where the external call is made out to AWS.
        for(String strMetric : m_oMetrics)
        {
        	GetMetricStatisticsResult oResult = null;
        	// Use Cases #1
    		if (IConstants.ALL_RDS_STATS.equals(strStatsType)) 
    		{
    			oResult = buildRequestForAllRDSStats(oClient, strMetric, oStartTime, oEndTime, iDataGranularity);
    		}
    		else // All other use cases
    		{
    			oResult = getResultForUseCases(oClient, strStatsType, strMetric, strDimensionInput, oStartTime, oEndTime, iDataGranularity);
    		}
    		
        	log.finer("oResult: " + oResult);
        	if (oResult != null) oResultList.add(oResult);
        }
        
        log.fine("[DEBUG] Result List Size: " + oResultList.size());
        
        // Save the results to DT
        saveResults(oResultList, env);
        
		return new Status(Status.StatusCode.Success);
	}

	@Override
	public void teardown(MonitorEnvironment env) throws Exception {
	}
	 
	//********************
	// PRIVATE METHODS
	//********************
	
	/*
	 * Calculate how far back in time we go to grab metrics. Users should ensure they make this match the
	 * monitor execution schedule.
	 * For example, if we run the monitor every 5 mins, this *must* be set to 5 mins.
	 * Otherwise you could run the monitor every 5 minutes and yet pull back the last hours statistics.
	 * This would lead to very strange results.
	 */
	private int calculateDataGranularity(String strDataGranularity)
	{
		if (strDataGranularity.equals(IConstants.DATA_GRANULARITY_1MIN))
		{
			log.finer("1min granularity");
			return 60 * 1000;
		}
		else if (strDataGranularity.equals(IConstants.DATA_GRANULARITY_5MINS))
		{
			log.finer("5mins granularity");
			return 60 * 5 * 1000;
		}
		else if (strDataGranularity.equals(IConstants.DATA_GRANULARITY_10MINS))
		{
			log.finer("10 mins granularity");
			return 60 * 10 * 1000;
		}
		else if (strDataGranularity.equals(IConstants.DATA_GRANULARITY_15MINS))
		{
			log.finer("15 mins granularity");
			return 60 * 15 * 1000;
		}
		else if (strDataGranularity.equals(IConstants.DATA_GRANULARITY_30MINS))
		{
			log.finer("30 mins granularity");
			return 60 * 30 * 1000;
		}
		else if (strDataGranularity.equals(IConstants.DATA_GRANULARITY_1HOUR))
		{
			log.finer("1 hour granularity");
			return 60 * 60 * 1000;
		}
		else
		{
			log.info("Got a strange data granularity. This should never happen. Return 60.");
			return 60;
		}
	}
	
	private void saveResults(List<GetMetricStatisticsResult> oResultList, MonitorEnvironment oEnvironment)
	{
		// For each potentially subscribed measure, get the actual measure from the environment
		for (String strMeasureName : m_oMetrics)
		{
			Collection<MonitorMeasure> monitorMeasures = oEnvironment.getMonitorMeasures(IConstants.MEASURE_GROUP_NAME, strMeasureName);
			log.fine("Monitor measures size for: " + strMeasureName + " - " + monitorMeasures.size()); // Should always be 1.
			
			for (MonitorMeasure subscribedMonitorMeasure : monitorMeasures)
			{
				List<Datapoint> oResultDatapoints = getResultMetricDatapoints(strMeasureName, oResultList);
				
				log.fine("oResultDatapoints Size: " + oResultDatapoints.size()); // Need to make sure this is always 1.
				
				// For each target aggregation, push the data into DT
				for (String strAggregation : m_oAggregationList)
				{
					MonitorMeasure oDynamicMeasure = oEnvironment.createDynamicMeasure(subscribedMonitorMeasure, "Aggregation", strAggregation);
					
					if (strAggregation.equals(IConstants.AGGREGATION_MINIMUM))
					{
						// Need to make sure this only ever contains one datapoint.... Aggregation settings?
						for (Datapoint oDP : oResultDatapoints)
						{
							// AWS returns -1 in case of no data. Only push metrics to DT if data is valid.
							double dValue = oDP.getMinimum();
							
							log.finer("Setting value for MIN: " + dValue);
							
							if (dValue >= 0) oDynamicMeasure.setValue(dValue);
						}
					}
					else if (strAggregation.equals(IConstants.AGGREGATION_AVERAGE))
					{
						// Need to make sure this only ever contains one datapoint.... Aggregation settings?
						for (Datapoint oDP : oResultDatapoints)
						{
							// AWS returns -1 in case of no data. Only push metrics to DT if data is valid.
							double dValue = oDP.getAverage();
							
							log.finer("Setting value for AVG: " + dValue);
							
							if (dValue >= 0) oDynamicMeasure.setValue(dValue);
						}
					}
					else if (strAggregation.equals(IConstants.AGGREGATION_MAXIMUM))
					{
						// Need to make sure this only ever contains one datapoint.... Aggregation settings?
						for (Datapoint oDP : oResultDatapoints)
						{
							// AWS returns -1 in case of no data. Only push metrics to DT if data is valid.
							double dValue = oDP.getMaximum();
							
							log.finer("Setting value for MAX: " + dValue);
							
							if (dValue >= 0) oDynamicMeasure.setValue(dValue);
						}
					}
					else if (strAggregation.equals(IConstants.AGGREGATION_SUM))
					{
						// Need to make sure this only ever contains one datapoint.... Aggregation settings?
						for (Datapoint oDP : oResultDatapoints)
						{
							// AWS returns -1 in case of no data. Only push metrics to DT if data is valid.
							double dValue = oDP.getSum();
							
							log.finer("Setting value for SUM: " + dValue);
							
							if (dValue >= 0) oDynamicMeasure.setValue(dValue);
						}
					}
					else if (strAggregation.equals(IConstants.AGGREGATION_SAMPLE_COUNT))
					{
						// Need to make sure this only ever contains one datapoint.... Aggregation settings?
						for (Datapoint oDP : oResultDatapoints)
						{
							// AWS returns -1 in case of no data. Only push metrics to DT if data is valid.
							double dValue = oDP.getSampleCount();
							
							log.finer("Setting value for SAMPLE COUNT: " + dValue);
							
							if (dValue >= 0) oDynamicMeasure.setValue(dValue);
						}
					}
					else
					{
						log.info("Found something else.. Should never happen");
					}	
				} // End for each aggregation list.
			} // End for each monitor.
		} // End for each measure name.
	}
		
	/*  Helper Method 
	 *  Find the AWS GetMetricStatisticsResult which matches the input String
	 *  and return its datapoints.
	 *  eg. datapoints which matches "RequestCount"
	 */
	private List<Datapoint> getResultMetricDatapoints(String strMeasureName, List<GetMetricStatisticsResult> oResultList)
	{
		for (GetMetricStatisticsResult oTmpResult : oResultList)
		{
			if (oTmpResult == null) continue;
			if (oTmpResult.getLabel().equals(strMeasureName)) return oTmpResult.getDatapoints();
		}
		
		return new ArrayList<Datapoint>();
	}
	
	// Use Case #1
	private GetMetricStatisticsResult buildRequestForAllRDSStats(AmazonCloudWatch oClient, String strMetricName, Date oStartTime, Date oEndTime, int iDataGranularity)
	{
		GetMetricStatisticsRequest oRequest = new GetMetricStatisticsRequest()
	            .withStartTime(oStartTime)
	            .withNamespace(IConstants.AWS_NAMESPACE)
	            .withPeriod(iDataGranularity)
	            .withMetricName(strMetricName)
	            .withStatistics(m_oAggregationList)
	            .withEndTime(oEndTime);
		
		GetMetricStatisticsResult oResult = null;
	    
	    // Now actually go out to AWS and get the metrics. This can fail.
	    try
	    {
	    	oResult = oClient.getMetricStatistics(oRequest);
	    }
	    catch (Exception e)
	    {
	    	log.severe("Error getting metrics from AWS. Returning null. " + e.getMessage());
	    }
	    
	    return oResult;
	    
	}
	
	/* Per use case request builder.
	 * Depending on the use case, dynamically build the request and get the result.
	 */
	private GetMetricStatisticsResult getResultForUseCases(AmazonCloudWatch oClient, String strStatsType, String strMetricName, String strDimensionValue, Date oStartTime, Date oEndTime, int iDataGranularity)
	{
		String strDimensionName = "";
		if (strStatsType.equals(IConstants.PER_DB_RDS_STATS)) strDimensionName = IConstants.DIMENSION_NAME_DB_INSTANCE_ID;
		else if (strStatsType.equals(IConstants.PER_DB_RDS_STATS)) strDimensionName = IConstants.DIMENSION_NAME_DB_ENGINE_NAME;
		else if (strStatsType.equals(IConstants.PER_DB_ENGINE_STATS)) strDimensionName = IConstants.DIMENSION_NAME_DB_ENGINE_NAME;
		else if (strStatsType.equals(IConstants.PER_DB_CLASS_STATS)) strDimensionName = IConstants.DIMENSION_NAME_DB_CLASS;
		else log.severe("Got unknown stats type. This should never happen. Stats Type: " + strStatsType);
		
		GetMetricStatisticsRequest oMetricRequest = new GetMetricStatisticsRequest()
	            .withStartTime(oStartTime)
	            .withNamespace(IConstants.AWS_NAMESPACE)
	            .withPeriod(iDataGranularity)
	            .withDimensions(new Dimension().withName(strDimensionName).withValue(strDimensionValue))
	            .withMetricName(strMetricName)
	            .withStatistics(m_oAggregationList)
	            .withEndTime(oEndTime);
		
		GetMetricStatisticsResult oResult = null;
	    
	    // Now actually go out to AWS and get the metrics. This can fail.
	    try
	    {
	    	oResult = oClient.getMetricStatistics(oMetricRequest);
	    }
	    catch (Exception e)
	    {
	    	log.severe("Error getting metrics from AWS. Returning null. " + e.getMessage());
	    }
	    
	    return oResult;
	}
}
